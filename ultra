/*
   Projeto: Hiperperiférico BitDogLab
   Plataforma: Raspberry Pi Pico W (BitDogLab)
   
   Funcionalidades integradas:
     - Display OLED 128x64 (SSD1306) via I²C:
         SDA: GPIO 14, SCL: GPIO 15
     - Botões táteis:
         Botão A: GPIO 5 (pull-up)
         Botão B: GPIO 6 (pull-up)
     - Joystick tátil:
         Eixo X (VRx): ADC no GPIO 26
         Eixo Y (VRy): ADC no GPIO 27
         Botão do Joystick: GPIO 22 (pull-up)
     - Comunicação:
         Interna: Display, botões e joystick se comunicam via I²C, ADC e GPIO.
         Externa:
            • PC: USB (stdio)
            • Smartphone: módulo Bluetooth via UART1 (TX: GPIO 8, RX: GPIO 9)
            
   O sistema exibe uma mensagem inicial e, no loop principal, verifica:
     - Se o Botão A for pressionado: exibe e envia "Botao A: clique!"
     - Se o Botão B for pressionado: exibe e envia "Botao B: comunicacao!"
     - Se o botão do Joystick for pressionado: lê os valores dos eixos, converte em porcentagem, exibe e envia os valores.
     - Caso contrário, exibe "pronto pra uso".
*/

#include <stdio.h>
#include "pico/stdlib.h"
#include "hardware/i2c.h"
#include "hardware/gpio.h"
#include "hardware/adc.h"
#include "hardware/uart.h"
#include "ssd1306.h"  // Biblioteca para o display OLED (adaptada para o Pico W/BitDogLab)

// ----- Configurações do Display OLED (BLOCO 1) -----
#define I2C_PORT       i2c0
#define OLED_SDA_PIN   14
#define OLED_SCL_PIN   15
#define SSD1306_ADDR   0x3C  // Endereço padrão do SSD1306

// ----- Parâmetros de tempo -----
#define MSG_TIME_MS    3000   // Tempo para exibição inicial e de mensagens (ms)

// ----- Configurações dos Botões (BLOCO 2) -----
#define BUTTON_A_PIN   5
#define BUTTON_B_PIN   6

// ----- Configurações do Joystick (BLOCO 3) -----
#define JOYSTICK_X_PIN       26   // ADC para eixo X
#define JOYSTICK_Y_PIN       27   // ADC para eixo Y
#define JOYSTICK_BUTTON_PIN  22   // Botão do joystick

// ----- Configurações da Comunicação UART (BLOCO 4) -----
// Usaremos UART1 para comunicação Bluetooth (ex.: com smartphone)
// Escolhemos TX em GPIO 8 e RX em GPIO 9
#define BLUETOOTH_UART      uart1
#define UART_BAUDRATE       115200
#define UART_TX_PIN         8
#define UART_RX_PIN         9

int main() {
    // Inicializa o stdio para debug via USB
    stdio_init_all();
    sleep_ms(2000);  // Aguarda 2 segundos para estabilização

    // ----- Inicializa a interface I2C para o Display OLED -----
    i2c_init(I2C_PORT, 400 * 1000);
    gpio_set_function(OLED_SDA_PIN, GPIO_FUNC_I2C);
    gpio_set_function(OLED_SCL_PIN, GPIO_FUNC_I2C);
    gpio_pull_up(OLED_SDA_PIN);
    gpio_pull_up(OLED_SCL_PIN);

    // ----- Inicializa o display OLED -----
    ssd1306_t disp;
    if (!ssd1306_init(&disp, SSD1306_ADDR, I2C_PORT)) {
        printf("Erro ao inicializar o display OLED.\n");
        while (true) tight_loop_contents();
    }

    // ----- Inicializa os Botões -----
    gpio_init(BUTTON_A_PIN);
    gpio_set_dir(BUTTON_A_PIN, GPIO_IN);
    gpio_pull_up(BUTTON_A_PIN);

    gpio_init(BUTTON_B_PIN);
    gpio_set_dir(BUTTON_B_PIN, GPIO_IN);
    gpio_pull_up(BUTTON_B_PIN);

    // ----- Inicializa o Joystick -----
    adc_init();
    adc_gpio_init(JOYSTICK_X_PIN);  // Eixo X
    adc_gpio_init(JOYSTICK_Y_PIN);  // Eixo Y

    gpio_init(JOYSTICK_BUTTON_PIN);
    gpio_set_dir(JOYSTICK_BUTTON_PIN, GPIO_IN);
    gpio_pull_up(JOYSTICK_BUTTON_PIN);

    // ----- Inicializa a UART para comunicação Bluetooth (BLOCO 4) -----
    uart_init(BLUETOOTH_UART, UART_BAUDRATE);
    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);

    // ----- Exibe a mensagem de inicialização -----
    ssd1306_clear(&disp);
    ssd1306_draw_string(&disp, 0, 0, "ola! Vamos iniciar.");
    ssd1306_show(&disp);
    // Envia a mensagem via UART
    uart_puts(BLUETOOTH_UART, "ola! Vamos iniciar.\n");
    sleep_ms(MSG_TIME_MS);

    // ----- Loop Principal -----
    while (true) {
        // Leitura dos estados dos botões e do joystick
        bool buttonA = (gpio_get(BUTTON_A_PIN) == 0);       // Botão ativo quando em nível 0
        bool buttonB = (gpio_get(BUTTON_B_PIN) == 0);
        bool joystickBtn = (gpio_get(JOYSTICK_BUTTON_PIN) == 0);

        if (buttonA) {
            ssd1306_clear(&disp);
            ssd1306_draw_string(&disp, 0, 0, "Botao A: clique!");
            ssd1306_show(&disp);
            uart_puts(BLUETOOTH_UART, "Botao A: clique!\n");
            // Aguarda a liberação do botão A
            while (gpio_get(BUTTON_A_PIN) == 0) { sleep_ms(50); }
        }
        else if (buttonB) {
            ssd1306_clear(&disp);
            ssd1306_draw_string(&disp, 0, 0, "Botao B: comunicacao!");
            ssd1306_show(&disp);
            uart_puts(BLUETOOTH_UART, "Botao B: comunicacao!\n");
            while (gpio_get(BUTTON_B_PIN) == 0) { sleep_ms(50); }
        }
        else if (joystickBtn) {
            // Se o botão do joystick estiver pressionado, lê os valores dos eixos X e Y
            adc_select_channel(0);  // Eixo X (GPIO26)
            uint16_t x_val = adc_read();
            adc_select_channel(1);  // Eixo Y (GPIO27)
            uint16_t y_val = adc_read();

            // Converte os valores (0 a 4095) para porcentagem
            int x_percent = (x_val * 100) / 4095;
            int y_percent = (y_val * 100) / 4095;

            // Exibe os valores do joystick no display
            ssd1306_clear(&disp);
            char buffer[32];
            sprintf(buffer, "Joystick X: %d%%", x_percent);
            ssd1306_draw_string(&disp, 0, 0, buffer);
            sprintf(buffer, "Joystick Y: %d%%", y_percent);
            ssd1306_draw_string(&disp, 0, 12, buffer);
            ssd1306_draw_string(&disp, 0, 24, "Joystick acionado!");
            ssd1306_show(&disp);

            // Envia os valores via UART para comunicação Bluetooth
            sprintf(buffer, "Joystick X: %d%%, Y: %d%%\n", x_percent, y_percent);
            uart_puts(BLUETOOTH_UART, buffer);

            // Aguarda a liberação do botão do joystick
            while (gpio_get(JOYSTICK_BUTTON_PIN) == 0) { sleep_ms(50); }
        }
        else {
            // Estado padrão: nenhum dispositivo acionado
            ssd1306_clear(&disp);
            ssd1306_draw_string(&disp, 0, 0, "pronto pra uso");
            ssd1306_show(&disp);
            uart_puts(BLUETOOTH_UART, "pronto pra uso\n");
        }
        sleep_ms(100);
    }

    return 0;
}
